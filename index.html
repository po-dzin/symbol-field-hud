<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>SymbolField HUD</title>
<style>
:root{--bg:#fafafa;--fg:#111;--border:#e6e6e6;--muted:#666;}
body[data-theme="dark"]{--bg:#0f0f0f;--fg:#fafafa;--border:#222;}
body[data-theme="zen"]{--bg:#f9f7f2;--fg:#222;}
body[data-theme="light"]{--bg:#ffffff;--fg:#111;}
body{
 background:var(--bg);color:var(--fg);
 font:15px/1.5 Inter,system-ui,sans-serif;margin:0;
 transition:background .6s ease,color .3s ease;
}
/* mood-based gradients */
body[data-mood="ğŸ”´"]{background:radial-gradient(circle at 50% 20%,#ffb3b3,#1a0000);}
body[data-mood="ğŸŸ "]{background:radial-gradient(circle at 50% 20%,#ffd8b3,#331500);}
body[data-mood="ğŸŸ¢"]{background:radial-gradient(circle at 50% 20%,#c6ffcc,#00280d);}
body[data-mood="ğŸ”µ"]{background:radial-gradient(circle at 50% 20%,#b3e1ff,#001433);}
body[data-mood="ğŸŸ£"]{background:radial-gradient(circle at 50% 20%,#e5b3ff,#2b0044);}
h1{text-align:center;margin:20px 0;font-size:2rem;font-weight:600;letter-spacing:.03em;
 background:linear-gradient(90deg,#111,#555);
 -webkit-background-clip:text;-webkit-text-fill-color:transparent;}
body[data-mode="ğŸ”†"] h1{background:linear-gradient(90deg,#ff9800,#ffc400);}
body[data-mode="â™¾ï¸"] h1{background:linear-gradient(90deg,#38bdf8,#a855f7);}
body[data-mode="ğŸ•³ï¸"] h1{background:linear-gradient(90deg,#111,#333);}
.grid{max-width:1100px;margin:auto;display:grid;gap:18px;padding:0 16px}
@media(min-width:900px){.grid{grid-template-columns:280px 1fr 280px}}
.card{background:#fff;border:1px solid var(--border);border-radius:14px;overflow:hidden}
.hd{padding:12px 14px;border-bottom:1px solid var(--border);display:flex;justify-content:space-between;align-items:center}
.bd{padding:12px 14px}
.row{display:flex;align-items:center;gap:6px;flex-wrap:wrap}
.badge{border:1px solid var(--border);border-radius:999px;padding:3px 8px;font-size:12px}
.btn{border:1px solid var(--border);border-radius:999px;padding:5px 10px;background:none;cursor:pointer}
.btn[aria-current="true"]{background:var(--fg);color:var(--bg)}
.mono{font-family:ui-monospace,monospace}
.progress{height:6px;background:#e6e6e6;border-radius:999px;overflow:hidden}
.bar{height:100%;background:var(--fg)}
.hint{font-size:12px;color:var(--muted)}
.list{max-height:220px;overflow:auto;border:1px solid var(--border);border-radius:10px}
.item{padding:6px 10px;border-bottom:1px solid var(--border)}
.input{width:100%;padding:6px 12px;border:1px solid var(--border);border-radius:999px;font:inherit;background:none;color:inherit}
.command{display:flex;gap:8px;align-items:center;margin-bottom:10px}
.command button{padding:6px 14px}
.stack{display:flex;flex-direction:column;gap:8px}
.ritual{display:flex;justify-content:space-between;align-items:center;gap:12px;padding:10px;border:1px solid var(--border);border-radius:12px;background:rgba(0,0,0,0.02)}
.ritual.done{background:rgba(0,128,0,0.08)}
.ritual-main{display:flex;align-items:center;gap:10px}
.tests{font-size:12px;display:flex;flex-direction:column;gap:6px;margin-top:10px}
.hidden{display:none!important}
</style>
</head>
<body data-mode="â™¾ï¸" data-theme="status" data-mood="ğŸŸ¢">
<h1>SymbolField HUD</h1>
<div class="grid">
  <!-- LEFT: STATE -->
  <div>
    <div class="card">
      <div class="hd"><div id="t_state"></div>
        <div class="badge" id="dateBadge"></div>
        <div><select id="lang">
          <option value="ru">RU</option><option value="en">EN</option></select></div></div>
      <div class="bd">
        <div id="dateMoon"></div>

        <div class="row mt8" data-group="mode">
          <span class="badge">Mode</span>
          <button class="btn" id="m1" type="button" data-mode="ğŸ•³ï¸">ğŸ•³ï¸</button>
          <button class="btn" id="m2" type="button" data-mode="â™¾ï¸">â™¾ï¸</button>
          <button class="btn" id="m3" type="button" data-mode="ğŸ”†">ğŸ”†</button>
        </div>
        <div class="hint" id="mode_hint"></div>

        <div class="row mt8" data-group="mood">
          <span class="badge">Mood</span>
          <button class="btn" id="mo1" type="button" data-mood="ğŸ”´">ğŸ”´</button>
          <button class="btn" id="mo2" type="button" data-mood="ğŸŸ ">ğŸŸ </button>
          <button class="btn" id="mo3" type="button" data-mood="ğŸŸ¢">ğŸŸ¢</button>
          <button class="btn" id="mo4" type="button" data-mood="ğŸ”µ">ğŸ”µ</button>
          <button class="btn" id="mo5" type="button" data-mood="ğŸŸ£">ğŸŸ£</button>
        </div>
        <div class="hint" id="mood_hint"></div>

        <div class="row mt8" data-group="glyph">
          <span class="badge">Glyph</span>
          <button class="btn" id="g1" type="button" data-glyph="â€¢">â€¢</button><button class="btn" id="g2" type="button" data-glyph="âˆ£">âˆ£</button>
          <button class="btn" id="g3" type="button" data-glyph="â—¯">â—¯</button><button class="btn" id="g4" type="button" data-glyph="âŠ™">âŠ™</button>
          <button class="btn" id="g5" type="button" data-glyph="âˆ¿">âˆ¿</button>
        </div>
      </div>
    </div>

    <div class="card mt16"><div class="hd"><div id="t_xp"></div></div>
      <div class="bd">
        <div class="stack" id="xp"></div>
        <div class="hint" id="xp_total"></div>
      </div>
    </div>
  </div>

  <!-- CENTER -->
  <div>
    <div class="card"><div class="hd"><div>/quote</div></div>
      <div class="bd" id="quote">Â«ĞšĞ¾Ğ»ÑŒÑ†Ğ¾ Ğ´Ñ‹ÑˆĞ¸Ñ‚. Ğ—ĞµÑ€Ğ½Ğ¾ ÑĞ²ĞµÑ‚Ğ¸Ñ‚ÑÑ. Ğ¢Ğ¸ÑˆĞ¸Ğ½Ğ° Ğ´ĞµÑ€Ğ¶Ğ¸Ñ‚ Ñ„Ğ¾Ñ€Ğ¼Ñƒ.Â»</div></div>
    <div class="card mt16"><div class="hd"><div>/reminder</div></div>
      <div class="bd">âˆ£ â—¯ âŠ™ â†’ Vipassana + breath + charge (08:00)</div></div>
    <div class="card mt16"><div class="hd"><div>/log</div></div>
      <div class="bd">
        <div class="command">
          <input class="input" id="command" type="text" autocomplete="off" placeholder="/mode ğŸ”† | /glyph âŠ™ | note...">
          <button class="btn" id="runCommand" type="button">â–¶</button>
        </div>
        <div class="list" id="log"></div>
      </div></div>
  </div>

  <!-- RIGHT -->
  <div>
    <div class="card"><div class="hd"><div>/rituals</div></div>
      <div class="bd stack" id="rituals"></div></div>
    <div class="card mt16"><div class="hd"><div>/arc + /quest</div></div>
      <div class="bd" id="questCard">
        <div><span class="badge">Arc</span> <span class="mono">A1 â€” Awakening</span></div>
        <div class="mt8"><span class="badge">Quest</span> <span>Stabilize ritual loop</span></div>
      </div></div>
    <div class="card mt16"><div class="hd"><div>Theme</div></div>
      <div class="bd">
        <select id="theme">
          <option value="status">Status-depended</option>
          <option value="dark">Dark</option>
          <option value="zen">Zen</option>
          <option value="light">Light</option>
        </select>
      </div></div>
    <div class="card mt16 hidden" id="testsCard"><div class="hd"><div>Tests</div></div>
      <div class="bd">
        <button class="btn" id="runTests" type="button">Run tests</button>
        <div class="tests" id="testsOutput"></div>
        <div class="hint">Hint: append <code>#test</code> to the URL to toggle this panel.</div>
      </div></div>
  </div>
</div>

<script>
class SymbolFieldHUD {
  static TEXT = { ru: { state: "Ğ¡Ğ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ", xp: "ĞŸĞ°Ğ½ĞµĞ»ÑŒ Ğ¾Ğ¿Ñ‹Ñ‚Ğ°" }, en: { state: "State", xp: "XP Dashboard" } };
  static MODES = ["ğŸ•³ï¸", "â™¾ï¸", "ğŸ”†"];
  static MOODS = ["ğŸ”´", "ğŸŸ ", "ğŸŸ¢", "ğŸ”µ", "ğŸŸ£"];
  static GLYPHS = ["â€¢", "âˆ£", "â—¯", "âŠ™", "âˆ¿"];
  static THEMES = ["status", "dark", "zen", "light"];
  static MODE_HINTS = { "ğŸ•³ï¸": "shadow Â· depth Â· compression", "â™¾ï¸": "flow Â· synthesis Â· resonance", "ğŸ”†": "radiance Â· broadcast Â· clarity" };
  static MOOD_HINTS = { "ğŸ”´": "vital Â· active Â· embodied", "ğŸŸ ": "creative Â· expressive Â· warm", "ğŸŸ¢": "balanced Â· centered Â· organic", "ğŸ”µ": "clear Â· focused Â· calm", "ğŸŸ£": "integral Â· inspired Â· subtle" };
  static XP_SYMBOLS = { HP: "ğŸª¨", CP: "ğŸ’§", MP: "ğŸ”¥", DP: "ğŸŒ¬ï¸" };
  static XP_KEYS = ["HP", "CP", "MP", "DP"];
  static DEFAULT_XP = Object.freeze({ HP: 15, CP: 3, MP: 3, DP: 29 });
  static DEFAULT_RITUALS = Object.freeze([
    { id: "vipassana", title: "Vipassana + breath + charge", emoji: "ğŸ§˜â€â™‚ï¸", xpAward: { DP: 8, HP: 2 }, schedule: "daily", done: false },
    { id: "move10", title: "10m mobility / flow", emoji: "ğŸŒ€", xpAward: { HP: 6, DP: 2 }, schedule: "adhoc", done: false },
    { id: "create20", title: "20m glyph/sound sketch", emoji: "âœï¸", xpAward: { CP: 8, MP: 2 }, schedule: "adhoc", done: false }
  ]);
  static STORAGE_KEY = "symbolfield_hud_state_v9";
  static LEGACY_KEY = "symbolFieldHUDState";
  static LANG_KEY = "lang";

  constructor() {
    this.dom = {
      body: document.body,
      stateTitle: document.getElementById('t_state'),
      xpTitle: document.getElementById('t_xp'),
      xpPanel: document.getElementById('xp'),
      xpTotal: document.getElementById('xp_total'),
      modeHint: document.getElementById('mode_hint'),
      moodHint: document.getElementById('mood_hint'),
      log: document.getElementById('log'),
      theme: document.getElementById('theme'),
      lang: document.getElementById('lang'),
      dateMoon: document.getElementById('dateMoon'),
      command: document.getElementById('command'),
      runCommand: document.getElementById('runCommand'),
      rituals: document.getElementById('rituals'),
      testsCard: document.getElementById('testsCard'),
      testsOutput: document.getElementById('testsOutput'),
      runTests: document.getElementById('runTests'),
      dateBadge: document.getElementById('dateBadge')
    };
    this.storage = this.safeStorage();
    this.moonError = false;
    this.testsResults = [];
    this.state = this.loadState();
    this.bindEventHandlers();
    this.updateTestVisibility();
    this.render();
    this.updateMoon();
  }

  static today() {
    return new Date().toISOString().slice(0, 10);
  }

  static uid() {
    try {
      return crypto.randomUUID();
    } catch {
      return `id_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 8)}`;
    }
  }

  static cloneRituals() {
    return SymbolFieldHUD.DEFAULT_RITUALS.map((r) => ({
      id: r.id,
      title: r.title,
      emoji: r.emoji,
      xpAward: { ...r.xpAward },
      schedule: r.schedule,
      done: r.done
    }));
  }

  static cloneXp() {
    return { ...SymbolFieldHUD.DEFAULT_XP };
  }

  safeStorage() {
    try { return window.localStorage; } catch { return null; }
  }

  createDefaultState() {
    return {
      date: SymbolFieldHUD.today(),
      lang: 'ru',
      mode: 'â™¾ï¸',
      mood: 'ğŸŸ¢',
      glyph: 'â—¯',
      theme: 'status',
      moon: { phase: 'unknown', icon: 'ğŸŒ‘', quarter: 1 },
      xp: SymbolFieldHUD.cloneXp(),
      rituals: SymbolFieldHUD.cloneRituals(),
      log: []
    };
  }

  loadState() {
    const base = this.createDefaultState();
    if (!this.storage) {
      return base;
    }
    let raw = this.storage.getItem(SymbolFieldHUD.STORAGE_KEY);
    if (!raw) {
      raw = this.storage.getItem(SymbolFieldHUD.LEGACY_KEY);
    }
    if (!raw) {
      const legacyLang = this.storage.getItem(SymbolFieldHUD.LANG_KEY);
      if (legacyLang && SymbolFieldHUD.TEXT[legacyLang]) {
        base.lang = legacyLang;
      }
      return base;
    }
    try {
      const parsed = JSON.parse(raw) || {};
      const today = SymbolFieldHUD.today();
      const state = { ...base };
      if (typeof parsed.lang === 'string' && SymbolFieldHUD.TEXT[parsed.lang]) {
        state.lang = parsed.lang;
      }
      if (typeof parsed.mode === 'string' && SymbolFieldHUD.MODES.includes(parsed.mode)) {
        state.mode = parsed.mode;
      }
      if (typeof parsed.mood === 'string' && SymbolFieldHUD.MOODS.includes(parsed.mood)) {
        state.mood = parsed.mood;
      }
      if (typeof parsed.glyph === 'string' && SymbolFieldHUD.GLYPHS.includes(parsed.glyph)) {
        state.glyph = parsed.glyph;
      }
      if (typeof parsed.theme === 'string' && SymbolFieldHUD.THEMES.includes(parsed.theme)) {
        state.theme = parsed.theme;
      }
      if (parsed.moon && typeof parsed.moon === 'object') {
        const { phase, icon, quarter } = parsed.moon;
        if (typeof phase === 'string' && typeof icon === 'string' && Number.isFinite(quarter)) {
          state.moon = { phase, icon, quarter: Number(quarter) };
        }
      }
      if (parsed.xp && typeof parsed.xp === 'object') {
        for (const key of SymbolFieldHUD.XP_KEYS) {
          const value = Number(parsed.xp[key]);
          if (Number.isFinite(value)) {
            state.xp[key] = Math.max(0, Math.round(value));
          }
        }
      }
      if (Array.isArray(parsed.rituals)) {
        const defaults = SymbolFieldHUD.cloneRituals();
        state.rituals = defaults.map((def) => {
          const stored = parsed.rituals.find((r) => r && r.id === def.id);
          return { ...def, done: Boolean(stored?.done) };
        });
      }
      if (parsed.date === today) {
        state.date = today;
      } else {
        state.date = today;
        state.rituals = state.rituals.map((r) => ({ ...r, done: false }));
      }
      if (Array.isArray(parsed.log)) {
        state.log = parsed.log.slice(0, 200).map((item) => {
          const ts = Number(item?.ts);
          const text = typeof item?.text === 'string' ? item.text : '';
          const id = typeof item?.id === 'string' ? item.id : SymbolFieldHUD.uid();
          return { id, ts: Number.isFinite(ts) ? ts : Date.now(), text };
        }).filter((entry) => entry.text);
        state.log.sort((a, b) => b.ts - a.ts);
      }
      const legacyLang = this.storage.getItem(SymbolFieldHUD.LANG_KEY);
      if (legacyLang && SymbolFieldHUD.TEXT[legacyLang]) {
        state.lang = legacyLang;
      }
      return state;
    } catch {
      return base;
    }
  }

  saveState() {
    if (!this.storage) return;
    try {
      const payload = { ...this.state, log: this.state.log.slice(0, 200) };
      this.storage.setItem(SymbolFieldHUD.STORAGE_KEY, JSON.stringify(payload));
      this.storage.setItem(SymbolFieldHUD.LANG_KEY, this.state.lang);
    } catch {
      /* ignore storage quota issues */
    }
  }

  bindEventHandlers() {
    this.attachGroupHandlers('mode', 'âˆ· Mode â†’ ');
    this.attachGroupHandlers('mood', 'â™¦ Mood â†’ ');
    this.attachGroupHandlers('glyph', 'â— Glyph â†’ ');

    this.dom.theme?.addEventListener('change', (event) => {
      const value = event.target.value;
      if (SymbolFieldHUD.THEMES.includes(value) && this.setState({ theme: value })) {
        this.addLog(`â˜¼ Theme â†’ ${value}`);
      }
    });

    this.dom.lang?.addEventListener('change', (event) => {
      const value = event.target.value;
      if (SymbolFieldHUD.TEXT[value] && this.setState({ lang: value })) {
        this.updateMoon();
      }
    });

    this.dom.command?.addEventListener('keydown', (event) => {
      if (event.key === 'Enter') {
        this.executeCommand(this.dom.command.value, { clearInput: true });
      }
    });

    this.dom.runCommand?.addEventListener('click', () => {
      if (this.dom.command) {
        this.executeCommand(this.dom.command.value, { clearInput: true });
      }
    });

    this.dom.rituals?.addEventListener('click', (event) => {
      const button = event.target.closest('[data-ritual]');
      if (!button) return;
      const id = button.dataset.ritual;
      if (id) {
        this.toggleRitual(id);
      }
    });

    this.dom.runTests?.addEventListener('click', () => this.runTests());

    window.addEventListener('hashchange', () => this.updateTestVisibility());
  }

  updateTestVisibility() {
    const show = window.location.hash.includes('test');
    if (this.dom.testsCard) {
      this.dom.testsCard.classList.toggle('hidden', !show);
    }
    if (show) {
      this.renderTestsOutput();
    }
  }

  attachGroupHandlers(key, logPrefix) {
    document.querySelectorAll(`[data-${key}]`).forEach((button) => {
      button.addEventListener('click', () => {
        const value = button.dataset[key];
        if (!value) return;
        if (this.setState({ [key]: value })) {
          this.addLog(`${logPrefix}${value}`);
        }
      });
    });
  }

  setState(patch) {
    let changed = false;
    const next = { ...this.state };
    for (const [key, value] of Object.entries(patch)) {
      if (next[key] !== value) {
        next[key] = value;
        changed = true;
      }
    }
    if (!changed) {
      return false;
    }
    this.state = next;
    this.saveState();
    this.render();
    return true;
  }

  render() {
    const { mode, mood, theme, lang } = this.state;
    this.dom.body.dataset.mode = mode;
    this.dom.body.dataset.mood = mood;
    this.dom.body.dataset.theme = theme === 'status' ? mode : theme;

    const text = SymbolFieldHUD.TEXT[lang] || SymbolFieldHUD.TEXT.ru;
    if (this.dom.stateTitle) this.dom.stateTitle.textContent = text.state;
    if (this.dom.xpTitle) this.dom.xpTitle.textContent = text.xp;
    if (this.dom.modeHint) this.dom.modeHint.textContent = SymbolFieldHUD.MODE_HINTS[mode] || '';
    if (this.dom.moodHint) this.dom.moodHint.textContent = SymbolFieldHUD.MOOD_HINTS[mood] || '';
    if (this.dom.lang) this.dom.lang.value = lang;
    if (this.dom.theme) this.dom.theme.value = theme;
    if (this.dom.dateBadge) this.dom.dateBadge.textContent = this.state.date;

    this.markSelection('mode', mode);
    this.markSelection('mood', mood);
    this.markSelection('glyph', this.state.glyph);

    this.renderXp();
    this.renderLog();
    this.renderRituals();
    this.renderMoon();
  }

  markSelection(key, active) {
    document.querySelectorAll(`[data-${key}]`).forEach((btn) => {
      const value = btn.dataset[key];
      if (!value) return;
      if (value === active) {
        btn.setAttribute('aria-current', 'true');
      } else {
        btn.removeAttribute('aria-current');
      }
    });
  }

  renderXp() {
    if (!this.dom.xpPanel) return;
    this.dom.xpPanel.textContent = '';
    const frag = document.createDocumentFragment();
    for (const key of SymbolFieldHUD.XP_KEYS) {
      const value = Number(this.state.xp[key]) || 0;
      const wrap = document.createElement('div');
      wrap.className = 'mt8';
      const row = document.createElement('div');
      row.className = 'row';
      const label = document.createElement('strong');
      label.textContent = key;
      const icon = document.createElement('span');
      icon.textContent = SymbolFieldHUD.XP_SYMBOLS[key] || '';
      const amount = document.createElement('span');
      amount.className = 'mono';
      amount.textContent = String(value);
      row.append(label, icon, amount);
      const progress = document.createElement('div');
      progress.className = 'progress';
      const bar = document.createElement('div');
      bar.className = 'bar';
      bar.style.width = `${Math.min(100, value % 100)}%`;
      progress.append(bar);
      wrap.append(row, progress);
      frag.append(wrap);
    }
    this.dom.xpPanel.append(frag);
    if (this.dom.xpTotal) {
      const total = SymbolFieldHUD.XP_KEYS.reduce((sum, key) => sum + (Number(this.state.xp[key]) || 0), 0);
      this.dom.xpTotal.textContent = `Total Â· ${total}`;
    }
  }

  renderLog() {
    if (!this.dom.log) return;
    this.dom.log.textContent = '';
    const frag = document.createDocumentFragment();
    const locale = this.state.lang === 'ru' ? 'ru-RU' : 'en-GB';
    this.state.log.forEach((entry) => {
      const item = document.createElement('div');
      item.className = 'item mono';
      item.textContent = `[${new Date(entry.ts).toLocaleTimeString(locale)}] ${entry.text}`;
      frag.append(item);
    });
    this.dom.log.append(frag);
  }

  renderRituals() {
    if (!this.dom.rituals) return;
    this.dom.rituals.textContent = '';
    const frag = document.createDocumentFragment();
    this.state.rituals.forEach((ritual) => {
      const item = document.createElement('div');
      item.className = `ritual${ritual.done ? ' done' : ''}`;
      const main = document.createElement('div');
      main.className = 'ritual-main';
      const button = document.createElement('button');
      button.type = 'button';
      button.className = 'btn';
      button.dataset.ritual = ritual.id;
      button.textContent = ritual.done ? 'â˜…' : 'âœ¦';
      if (ritual.done) {
        button.setAttribute('aria-current', 'true');
      } else {
        button.removeAttribute('aria-current');
      }
      const info = document.createElement('div');
      const title = document.createElement('div');
      title.className = 'mono';
      title.textContent = `${ritual.emoji} ${ritual.title}`;
      const subtitle = document.createElement('div');
      subtitle.className = 'hint';
      const award = Object.entries(ritual.xpAward || {}).map(([k, v]) => `${k}+${v}`).join(' ') || 'â€”';
      subtitle.textContent = `award: ${award}`;
      info.append(title, subtitle);
      main.append(button, info);
      const badge = document.createElement('span');
      badge.className = 'badge';
      badge.textContent = ritual.schedule;
      item.append(main, badge);
      frag.append(item);
    });
    this.dom.rituals.append(frag);
  }

  renderMoon() {
    if (!this.dom.dateMoon) return;
    if (this.moonError) {
      this.dom.dateMoon.textContent = 'Moon API unavailable';
      return;
    }
    const locale = this.state.lang === 'ru' ? 'ru-RU' : 'en-GB';
    const dateStr = new Date().toLocaleDateString(locale, { day: 'numeric', month: 'long', year: 'numeric' });
    const moon = this.state.moon;
    if (moon) {
      this.dom.dateMoon.textContent = `${dateStr} Â· ${moon.icon} ${moon.phase} Â· Q${moon.quarter}`;
    } else {
      this.dom.dateMoon.textContent = dateStr;
    }
  }

  renderTestsOutput() {
    if (!this.dom.testsOutput) return;
    this.dom.testsOutput.textContent = '';
    const frag = document.createDocumentFragment();
    this.testsResults.forEach((line) => {
      const div = document.createElement('div');
      div.textContent = `â€¢ ${line}`;
      frag.append(div);
    });
    this.dom.testsOutput.append(frag);
  }

  addLog(text) {
    const entry = { id: SymbolFieldHUD.uid(), ts: Date.now(), text };
    const next = [entry, ...this.state.log].slice(0, 200);
    this.state = { ...this.state, log: next };
    this.saveState();
    this.renderLog();
    this.renderTestsOutput();
  }

  executeCommand(command, { clearInput = false } = {}) {
    const value = (command || '').trim();
    if (!value) return;
    const [cmd, arg] = value.split(/\s+/, 2);
    if (cmd === '/glyph' && arg && SymbolFieldHUD.GLYPHS.includes(arg)) {
      if (this.setState({ glyph: arg })) {
        this.addLog(`â— Glyph â†’ ${arg}`);
      }
    } else if (cmd === '/mode' && arg && SymbolFieldHUD.MODES.includes(arg)) {
      if (this.setState({ mode: arg })) {
        this.addLog(`âˆ· Mode â†’ ${arg}`);
      }
    } else if (cmd === '/mood' && arg && SymbolFieldHUD.MOODS.includes(arg)) {
      if (this.setState({ mood: arg })) {
        this.addLog(`â™¦ Mood â†’ ${arg}`);
      }
    } else {
      this.addLog(value);
    }
    if (clearInput && this.dom.command) {
      this.dom.command.value = '';
    }
  }

  toggleRitual(id) {
    const current = this.state.rituals.find((r) => r.id === id);
    if (!current) return;
    const toggled = !current.done;
    const rituals = this.state.rituals.map((r) => (r.id === id ? { ...r, done: toggled } : { ...r }));
    const xp = { ...this.state.xp };
    for (const [key, amount] of Object.entries(current.xpAward || {})) {
      const delta = Number(amount) || 0;
      if (!delta) continue;
      const present = Number(xp[key]) || 0;
      xp[key] = Math.max(0, Math.round(present + (toggled ? delta : -delta)));
    }
    if (this.setState({ rituals, xp })) {
      this.addLog(`${current.done ? 'âœ—' : 'âœ”'} Ritual ${current.title}`);
    }
  }

  runTests() {
    const results = [];
    const nextMode = SymbolFieldHUD.MODES.find((m) => m !== this.state.mode) || this.state.mode;
    const beforeMode = this.state.log.length;
    this.executeCommand(`/mode ${nextMode}`);
    const afterMode = this.state.log.length;
    results.push(`T1 /mode logged: ${afterMode > beforeMode ? 'OK' : 'FAIL'}`);

    const nextGlyph = SymbolFieldHUD.GLYPHS.find((g) => g !== this.state.glyph) || this.state.glyph;
    const beforeGlyph = this.state.log.length;
    this.executeCommand(`/glyph ${nextGlyph}`);
    const afterGlyph = this.state.log.length;
    results.push(`T2 /glyph logged: ${afterGlyph > beforeGlyph ? 'OK' : 'FAIL'}`);

    const nextMood = SymbolFieldHUD.MOODS.find((m) => m !== this.state.mood) || this.state.mood;
    const beforeMood = this.state.log.length;
    if (this.setState({ mood: nextMood })) {
      this.addLog(`â™¦ Mood â†’ ${nextMood}`);
    }
    const afterMood = this.state.log.length;
    results.push(`T3 mood click logged: ${afterMood > beforeMood ? 'OK' : 'FAIL'}`);

    this.testsResults = results;
    this.renderTestsOutput();
  }

  async updateMoon() {
    if (!this.dom.dateMoon) return;
    const now = Math.floor(Date.now() / 1000);
    try {
      const res = await fetch(`https://api.farmsense.net/v1/moonphases/?d=${now}`);
      const data = await res.json();
      const phase = data?.[0]?.Phase || 'unknown';
      let icon = 'ğŸŒ˜';
      let quarter = 4;
      if (phase.includes('New')) { icon = 'ğŸŒ‘'; quarter = 1; }
      else if (phase.includes('Waxing Crescent')) { icon = 'ğŸŒ’'; quarter = 1; }
      else if (phase.includes('First Quarter')) { icon = 'ğŸŒ“'; quarter = 2; }
      else if (phase.includes('Waxing Gibbous')) { icon = 'ğŸŒ”'; quarter = 2; }
      else if (phase.includes('Full')) { icon = 'ğŸŒ•'; quarter = 3; }
      else if (phase.includes('Waning Gibbous')) { icon = 'ğŸŒ–'; quarter = 3; }
      else if (phase.includes('Last Quarter')) { icon = 'ğŸŒ—'; quarter = 4; }
      else if (phase.includes('Waning Crescent')) { icon = 'ğŸŒ˜'; quarter = 4; }
      this.moonError = false;
      this.setState({ moon: { phase, icon, quarter } });
    } catch {
      this.moonError = true;
      this.renderMoon();
    }
  }
}

new SymbolFieldHUD();
</script>
</body>
</html>
